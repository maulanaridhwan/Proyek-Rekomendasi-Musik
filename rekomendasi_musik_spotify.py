# -*- coding: utf-8 -*-
"""Rekomendasi Musik Spotify.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1MWo9lVLWYL7eUK_965lD9-tSZIFSOQgO

# Rekomendasi Musik Spotify: Content-Based Filtering
**Dataset:**
### Top 10000 Songs on Spotify 1950-Present
The best and biggest songs from ARIA & Billboard charts spanning 7 decades.
https://www.kaggle.com/datasets/joebeachcapital/top-10000-spotify-songs-1960-now/data

## Import Library
"""

import pandas as pd
import numpy as np
from sklearn.preprocessing import MinMaxScaler
from sklearn.metrics.pairwise import cosine_similarity
from sklearn.feature_extraction.text import TfidfVectorizer
from scipy.sparse import hstack, csr_matrix
import random
import math

"""## Load Dataset"""

file_path = '/content/drive/MyDrive/Colab Notebooks/DBS Coding Camp 2025/MLT/Proyek Kedua/top_10000_1950-now.csv'
df = pd.read_csv(file_path)
df.head()

"""## Data Understanding & Cleaning"""

df.info()

df.shape

"""Ukuran dataset adalah (10000, 35). Artinya ada 10.000 lagu dan 35 kolom fitur (metadata + fitur audio)."""

# Kolom fitur audio dan metadata
audio_features = ['Danceability', 'Energy', 'Valence', 'Tempo', 'Loudness',
                  'Speechiness', 'Acousticness', 'Instrumentalness', 'Liveness']

# Drop baris dengan missing pada fitur audio, Artist Name(s), Track Name, Artist Genres
df = df.dropna(subset=audio_features + ['Artist Name(s)', 'Track Name', 'Artist Genres']).reset_index(drop=True)

df.info()

# Ekstrak "primary artist" dari kolom 'Artist Name(s)'
def get_primary_artist(artist_str):
    if isinstance(artist_str, str) and artist_str.strip() != '':
        return artist_str.split(',')[0].strip()
    return ''

# Ekstrak "primary genre" dari kolom 'Artist Genres'
def get_primary_genre(genres):
    if isinstance(genres, str) and genres.strip() != '':
        return genres.split(',')[0].strip()
    return ''

# Terapkan ekstraksi pada DataFrame baru _df
c_df = df.copy()
c_df['Primary Artist'] = c_df['Artist Name(s)'].apply(get_primary_artist)
c_df['Primary Genre'] = c_df['Artist Genres'].apply(get_primary_genre)

# Buat ID unik untuk setiap track setelah cleaning
df_clean = c_df.copy().reset_index(drop=True)
df_clean['Track ID'] = df_clean.index

# Drop Duplikat Judul
# Jika ada duplikat Track Name, simpan hanya entri dengan Popularitas tertinggi
df_clean = df_clean.sort_values('Popularity', ascending=False).drop_duplicates(subset=['Track Name'])
df_clean = df_clean.reset_index(drop=True)
# Update Track ID setelah drop duplikat
df_clean['Track ID'] = df_clean.index

df_clean.shape

"""## Data Preparation

Normalisasi fitur audio dengan MinMaxScaler agar masing-masing berada di rentang 0-1. Proses kolom 'Artist Genres' menjadi vektor TF-IDF (maksimal 200 fitur) untuk menangkap informasi genre. Ubah matriks fitur audio menjadi format sparse untuk efisiensi. Gabungkan matriks audio (sparse) dan TF-IDF genre menjadi satu matriks fitur gabungan.
"""

# Skala fitur audio dengan MinMaxScaler (0-1)
scaler = MinMaxScaler()
df_clean[audio_features] = scaler.fit_transform(df_clean[audio_features])

# Buat TF-IDF untuk kolom 'Artist Genres'
vectorizer = TfidfVectorizer(stop_words='english', max_features=200)  # batasi dimensi
genre_tfidf = vectorizer.fit_transform(df_clean['Artist Genres'])  # sparse matrix shape=(n_songs, n_genre)

# Ubah matriks fitur audio menjadi sparse
audio_matrix = csr_matrix(df_clean[audio_features].values)

# Gabungkan fitur audio + TF-IDF genre
combined_features = hstack([audio_matrix, genre_tfidf])  # shape: (n_songs, n_audio + n_genre)

"""### Hitung Similarity Matrix
Hitung cosine similarity di antara semua baris (lagu) pada matriks fitur gabungan. Hasilnya adalah matriks sim_matrix berukuran (n_songs, n_songs).
"""

# Cosine similarity (sparse)
sim_matrix = cosine_similarity(combined_features, dense_output=False)

"""### Mapping untuk Rekomendasi
- track_to_idx: mapping dari judul lagu ke Track ID (index)
- idx_to_track: mapping dari Track ID ke judul lagu
- idx_to_artist: mapping dari Track ID ke primary artist
- idx_to_genre: mapping dari Track ID ke primary genre
"""

# Mapping untuk Rekomendasi
track_to_idx = pd.Series(df_clean['Track ID'].values, index=df_clean['Track Name']).to_dict()
idx_to_track = pd.Series(df_clean['Track Name'].values, index=df_clean['Track ID']).to_dict()
idx_to_artist = pd.Series(df_clean['Primary Artist'].values, index=df_clean['Track ID']).to_dict()
idx_to_genre = pd.Series(df_clean['Primary Genre'].values, index=df_clean['Track ID']).to_dict()

# Fungsi rekomendasi: diberikan judul track, k, kembalikan top k rekomendasi
def recommend(track_name, top_k=10):
    if track_name not in track_to_idx:
        print(f"Track '{track_name}' tidak ditemukan dalam dataset.")
        return []
    idx = track_to_idx[track_name]
    sim_scores = list(enumerate(sim_matrix[idx].toarray().ravel()))
    sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)
    recommendations = []
    count = 0
    for i, score in sim_scores:
        if i == idx:
            continue
        recommendations.append((idx_to_track[i], idx_to_artist[i], idx_to_genre[i], score))
        count += 1
        if count >= top_k:
            break
    return recommendations

# Uji rekomendasi
example_track = df_clean['Track Name'].iloc[0]
print("Track contoh:", example_track)
print("Rekomendasi 5 lagu mirip:")
for track, artist, genre, score in recommend(example_track, top_k=5):
    print(f"{track} - {artist} [{genre}] (score: {score:.4f})")

"""## Evaluasi Model"""

# Evaluasi (Precision@10, Recall@10, NDCG@10) Berdasarkan Primary Genre
def precision_at_k(relevant, recommended, k):
    recommended_k = recommended[:k]
    if not recommended_k:
        return 0.0
    true_positives = sum([1 for r in recommended_k if r in relevant])
    return true_positives / k


def recall_at_k(relevant, recommended, k):
    recommended_k = recommended[:k]
    if not relevant:
        return 0.0
    true_positives = sum([1 for r in recommended_k if r in relevant])
    return true_positives / len(relevant)


def ndcg_at_k(relevant, recommended, k):
    dcg = 0.0
    for i, rec in enumerate(recommended[:k]):
        if rec in relevant:
            dcg += 1 / math.log2(i + 2)
    ideal_rels = min(len(relevant), k)
    idcg = sum([1 / math.log2(i + 2) for i in range(ideal_rels)])
    return dcg / idcg if idcg > 0 else 0.0

# sampel query untuk evaluasi (100 track random)
random.seed(42)
sample_indices = random.sample(list(df_clean['Track ID']), 100)
eval_results = []
K = 10

for q_idx in sample_indices:
    # Tentukan relevant sebagai set lagu dengan Primary Genre sama (kecuali diri sendiri)
    query_genre = idx_to_genre[q_idx]
    relevant_tracks = set(
        df_clean.loc[
            (df_clean['Primary Genre'] == query_genre) & (df_clean['Track ID'] != q_idx),
            'Track Name'
        ].values
    )
    query_track = idx_to_track[q_idx]
    recs = [name for name, artist, genre, _ in recommend(query_track, top_k=K)]
    prec = precision_at_k(relevant_tracks, recs, K)
    rec_score = recall_at_k(relevant_tracks, recs, K)
    ndcg = ndcg_at_k(relevant_tracks, recs, K)
    eval_results.append((prec, rec_score, ndcg))

# Hitung rata-rata metrik
eval_df = pd.DataFrame(eval_results, columns=['Precision@10', 'Recall@10', 'NDCG@10'])
print("\nHasil Evaluasi Rata-Rata:")
print(eval_df.mean())

"""Nilai Precision@10 dan NDCG@10 menunjukkan sistem sudah mampu memilih dan meranking lagu‐lagu yang satu genre dengan input. Itu berarti sudah baik untuk content‐based filtering di skala 10.000 lagu. Recall yang lebih rendah dapat dipahami karena jumlah lagu dalam satu genre sangat banyak, sementara rekomendasi dibatasi 10 entri saja."""

# Rekomendasi 10 Lagu
query = input("Masukkan judul lagu (Track Name): ")
results = recommend(query, top_k=10)
if results:
    print(f"\nRekomendasi 10 lagu mirip dengan '{query}':")
    for i, (track, artist, genre, score) in enumerate(results, start=1):
        print(f"{i}. {track} - {artist} [{genre}] (similarity: {score:.4f})")